## 一、标志位及序号
（1）SYN标志位：同步标志，表示建立连接连接。  
（2）ACK标志位：确认标志，确认序号有效  
（3）seq序号：用来标识从TCP源端向目的端发送的字节流  
（4）ack序号：只有ACK标志位为1时，确认序号字段才有效，ack=seq+1，确认seq序号的包成功接收  

## 二、TCP三次握手

### 1、三次握手过程
![image](https://github.com/ym652324/network/blob/master/image/QQ%E5%9B%BE%E7%89%8720181012165306.png)
（1）客户端发送包，其中标志位SYN=1（生成序号seq=x），进入SYN_SENT状态  
（2）服务器端接收到包，识别到SYN=1，发送确认包，ACK=1（ack=x+1），SYN=1（seq=y）  
（3）客户端接收到确认包，发送确认包ACK=1，ack=y+1，seq=x+1  

### 2、为什么TCP客户端最后还要发送一次确认呢？两次握手不行吗？
>> 不行，主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。  
>> 如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。

## 三、TCP四次挥手
### 1、四次挥手过程
![image](https://github.com/ym652324/network/blob/master/image/20170606084851272.png)
（1）客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。  
（2）服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。  
（3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。  
（4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。  
（5）客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。  
（6）服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。  

